INSERT INTO public.pattern_language  (id, name, uri, graph, logo) VALUES ('1f1120b5-702e-44bb-9efc-18c9ac66aa6f', 'Microservice API Patterns', 'https://patternpedia.org/patternLanguages/microserviceApiPatterns', NULL, NULL);
INSERT INTO public.pattern_schema (pattern_language_id) VALUES ('1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('51048938-521f-474a-9db9-58e76ccf3725', 'Context', 'Context', 0, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('4a351211-d689-4fab-af0d-f381e23a51ee', 'Problem', 'Problem', 1, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('e3443d1e-2270-46e6-8113-93b32d87ad65', 'Forces', 'Forces', 2, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('150a01c6-a843-4654-a06d-b6455d6a8c4b', 'Details', 'Details', 3, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('76b95cec-2380-47bb-b5a1-127b62ab5f96', 'Non-solution', 'Non-solution', 4, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('fb53e625-0038-437b-881c-f603fe686056', 'Solution', 'Solution', 5, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('b14b1616-15e9-4587-9f2b-ff77879380e4', 'How it works', 'How it works', 6, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('6df6882f-6ac0-46b0-b456-66785e1abfcb', 'Example', 'Example', 7, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('a86ab394-6045-4bcd-9464-218d8d33ccab', 'Implementation hints', 'Implementation hints', 8, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('4a6a5a22-aac5-4e49-a7cd-35d7ed5d8924', 'Consequences', 'Consequences', 9, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('01908b2b-2b45-4c64-ad5e-c651724cef51', 'Resolution of forces', 'Resolution of forces', 10, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('8da3f1fe-1d4e-4432-ad20-96f4465a3fa4', 'Further discussion', 'Further discussion', 11, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('d77a84f8-6056-4d52-9245-482e97729e52', 'Known Uses', 'Known Uses', 12, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('5d3f01d0-f540-4014-8a03-ee13d923cc83', 'More Information', 'More Information', 13, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('9e9e4f80-4cdb-43bf-ad78-6dd19e81da60', 'Related Patterns', 'Related Patterns', 14, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('2f83e80a-aa8d-4339-8492-1763f0bdce1b', 'Other Sources', 'Other Sources', 15, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('0e945b65-b53f-4474-8f64-58055c4c38a4', 'References', 'References', 16, 'any', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id) VALUES ('0c494d05-23db-42aa-aaab-1713a6a2215e', 'Two in Production', 'https://patternpedia.org/patternLanguages/microserviceApiPatterns/twoInProduction', '{"Forces": "*Two in Production* balances the following forces:\n* Allowing the provider and the client to follow *different life cycles* so that a provider can roll out a new API version without breaking clients using the previous API version.\n* Guaranteeing that API changes do not lead to *undetected backwards-compatibility problems* between clients and the provider.\n* Ability to *roll back* if a new API version is designed badly. \n* Minimizing *changes to the client* caused by API changes.\n* Minimizing the *maintenance effort* for supporting clients relying on old API versions.", "Context": "An API evolves and new versions with improved functionality are offered regularly. At some point in time, the changes of a new version are not backwards compatible anymore, thereby \"breaking\" existing clients. However, clients, especially of a *Public API* or a *Community API*, evolve at different speeds; some of them cannot be forced to upgrade to the latest version in a short time frame because the release cycles of the provider(s) and client(s) do not align well with each other.", "Details": "Under independent life cycles with different deployment frequencies and deployment dates of providers and their clients, it becomes necessary to plan API evolution beforehand because it is impossible to make arbitrary changes to an already published API.\n\n**Allowing the provider and the client to follow different life cycles.** When changing an API over time, one of the main problems is how (and for how long) to support clients of older API versions. Keeping old API versions alive usually requires additional resources and effort for operations and maintenance, for instance for bug fixes, security fixes, migrations to newer versions of dependencies, and subsequent regression testing for different API versions. This inflicts cost and binds development resources on the provider side. \nHowever, it is not always possible to just switch off an old version because clients often do not follow the same life cycle: Even within the same company it is difficult or even impossible to roll out two systems at the same point in time, especially if they are owned by different organizational units. The problem becomes worse if there are multiple clients which are owned by different organizations or the clients are even unknown to the provider (e.g., in *Public API* scenarios). Thus, it is often necessary to decouple the life cycles of the client and the provider. Such autonomy/independent life cycles are one of the core tenets of microservices.\n\n**Guaranteeing that API changes do not lead to undetected backwards-compability problems (especially in semantics) between clients and the provider.**  Introducing backwards-compatible changes only is hard, in particular if done without the proper tooling. There is a risk of changes that will quietly introduce problems, e.g., by changed semantics of existing attributes in requests and responses, which cannot be detected syntactically.\n\n**Ability to roll back if a new API version is designed badly.** When redesigning or restructuring an API thoroughly, the new design might not work as expected. For example, functionality required by some clients might unintentionally be removed. Being able to fall back and undo a change helps to not break those clients for a longer time-span.\n\n**Minimizing changes to the client.** Clients in general prefer stability. When API is released it can be assumed to work as intended. Only changes solely required for satisfying (technical) API changes require the clients to be updated in that case. Such updates bind resources and cost money (which would be better spent for delivering more business value). However, providing such highly stable APIs requires more upfront effort on the provider side; provider-side agility may trigger undesired client-side changes.\n\n**Minimizing the maintenance effort for supporting clients relying on old API versions.** The solution must not only take the client effort into consideration, but balance it with the effort on the provider side to maintain multiple API versions, for instance versions supporting not frequently used (and therefore unprofitable) features.", "Example": "A business software vendor releases an API (Version 1) to its Enterprise Resource Planning (ERP) system. In the continued development of the ERP system, an existing payroll API in the HR module is extended; at some point, new pension plan management features break the API because the data retention policies are incompatible. Because the vendor uses the *Two in Production* pattern, it releases its software with the old API (Version 1) and the new API (Version 2). Customers that use Version 1 can roll out the ERP system (HR module) and then start migrating to use Version 2. New customers in the affected country can start to use the new features of the API Version 2 right away.\nWith the next release, the software vendor again releases a new API (Version 3) and removes support for Version 1 because Versions 2 and 3 are now supported. Customers that still use Version 1 are cut off until they have migrated to a more recent version (that they can be redirected to). Clients using Version 2 can stay on Version 2 until the next API version is released. ", "Problem": "How can a provider gradually update an API without breaking existing clients, but also without having to maintain a large number of API versions in production?", "Solution": "Deploy and support two versions of an API endpoint and its operations that provide variations of the same functionality, but do not have to be compatible with each other. Update and decommission (i.e., deprecate and remove) the versions in a rolling, overlapping fashion.\nAs a variant, consider to support more than two versions, for instance three. ", "Known Uses": "Known uses for this pattern include:\n* Terravis @Luebke:2016 offers two major versions in parallel for two years.\n* A large bank in Europe keeps two major versions (see *Semantic Versioning* for definition of \"major\") in parallel.\n* The Dynamic Interface described in @Brandner:2004:SI applies the pattern as well.\n* [GitHub offers a v3 API, but also the next version in parallel](https://developer.github.com/v3/versions/).\n* Facebook describes a rolling release and update policy as well, which is a defining characteristic of *Two in Production*. See their documentation page [\"Platform Versioning\"](https://developers.facebook.com/docs/apps/versions). ", "References": "Brandner, Michael, Michael Craes, Frank Oellermann, and Olaf Zimmermann. 2004. “Web Services-Oriented Architecture in Production in the Finance Industry.” Informatik-Spektrum 27 (2): 136–45. [https://doi.org/10.1007/s00287-004-0380-2](https://doi.org/10.1007/s00287-004-0380-2) \n\nFachat, André. 2019. “Challenges and Benefits of the Microservice Architectural Style.” IBM Developer. [https://developer.ibm.com/articles/challenges-and-benefits-of-the-microservice-architectural-style-part-2/](https://developer.ibm.com/articles/challenges-and-benefits-of-the-microservice-architectural-style-part-2/).\n\nHohpe, Gregor, and Bobby Woolf. 2003. Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions. Addison-Wesley.\n\nLübke, Daniel, and Tammo van Lessen. 2016. “Modeling Test Cases in BPMN for Behavior-Driven Development.” IEEE Software 33 (5): 15–21.\n\nMurer, Stephan, Bruno Bonati, and Frank Furrer. 2010. Managed Evolution - a Strategy for Very Large Information Systems. Heidelberg: Springer.\n\nPautasso, Cesare, Olaf Zimmermann, Mike Amundsen, James Lewis, and Nicolai M. Josuttis. 2017. “Microservices in Practice, Part 1: Reality Check and Service Design.” IEEE Software 34 (1): 91–98. [https://doi.org/10.1109/MS.2017.24](https://doi.org/10.1109/MS.2017.24).\n\nRichardson, Chris. 2016. “Microservice Architecture.” [http://microservices.io](http://microservices.io).", "Consequences": "", "How it works": "Such a rolling dual support strategy can be realized in the following way:\n* Choose how to identify a version (e.g., by using the *Version Identifier* pattern).\n* Offer a fixed number (usually two, thus the pattern name) of API versions in parallel and inform your clients about this life cycle choice.\n* When releasing a new API version, retire the oldest one that still runs in production and inform remaining clients (if any) about their migration options. Redirect calls to the retired version, for instance by leveraging protocol-level capabilities such as those in HTTP.\n By following these steps, a sliding window of active versions is created (see figure below). Thereby, providers allow clients to choose the time of migration to a newer version. If a new version is released, the client can continue to use the previous version and migrate later on (e.g., within a given time frame if the *Limited Lifetime Guarantee* is applied as well). They can learn about the API changes and required client-side modifications without risking the stability of their own primary production system.\n \n ![Version Life Cycles when Using Two In Production](https://microservice-api-patterns.org/patterns/evolution/TwoInProduction.png)\n \n Although typically two versions are offered in parallel, this pattern can also be applied in a slightly changed variant as *N in Production* (or *Several in Production*) where the sliding window of active versions is increased to N (with N greater than 2). This strategy gives clients more time to migrate but places more maintenance effort and operational costs on the provider side. \n \n For example, with three in production, one version may be for legacy clients, one for current clients and one for future ones/early adopters (with the newest version serving as *Experimental Preview*). Only when all legacy traffic disappears, Version 1 can be switched off; Version 2 becomes the legacy as Version 3 stabilizes and a new Version 4 can be experimented with. The oldest one then becomes the legacy in turn, and the newest one can be offered to experimental clients while also providing access to the current stable version.", "Non-solution": "An obvious \"solution\" is not to care about versioning, always roll out the newest version, and force clients to \"live at the head\".  For instance, in the past some enterprise-wide Service-Oriented Architecture (SOA) initiatives have been rolled out without any considerations to versioning and life cycle management with the intention to add such capabilities later on. This is difficult, if not impossible: as soon as an API or service is published, clients will use it and are thus bound to the API; not all changes can be expected to be backward compatible. In such situations, organizations have to mitigate the problems as quickly as possible and roll out the new version side-by-side to the old version. While this solves the problem in the short term, the growing numbers of available API versions are hard to maintain for the providers and confusion starts with regard to which API version and associated deployment are to be used.", "Other Sources": "\"Managed Evolution\" covers life cycle management on a general level, but also dives into API versioning. Section 3.5.4 reports a combined usage of *Semantic Versioning* and *Two in Production*. Three versions are reported to have proven as a good compromize between provider complexity and adaptation pace Murer, Bonati, and Furrer ([2010](https://microservice-api-patterns.org/patterns/evolution/TwoInProduction.html#ref-Murer:2010)).\n\n\"Challenges and benefits of the microservice architectural style\", a two-part article on the IBM Developer portal Fachat ([2019](https://microservice-api-patterns.org/patterns/evolution/TwoInProduction.html#ref-Fachat:2019)), recommends this pattern.", "More Information": "", "Related Patterns": "The usage of this pattern usually requires the *Version Identifier* pattern in order to distinguish the API versions that are currently active and supported concurrently. Fully compatible versions, e.g., as indicated by the patch version in *Semantic Versioning* can replace active versions without violating the *Two in Production* constraints. This should be reported in the *API Description* and/or the *Service Level Agreement*.\n\n*Aggressive Obsolescence* can be used to force clients to stop using the older API version and migrate to the newer one so that the provider can introduce an even newer API version. If the client requires more guarantees on the expiration date of the old API version, the *Limited Lifetime Guarantee* pattern might be more applicable. An *Experimental Preview* can be one of the versions in production. ", "Further discussion": "By using *Two in Production*, the life cycle of provider and client are decoupled to a certain extent: clients do not need to synchronously release their software with the provider. Instead, they have a time window in which they can migrate, test, and release their software. However, clients must migrate as they cannot rely on an *Eternal Lifetime Guarantee* for the API. This means that they have to plan and allocate resources for migrating their software.\n\nWhen this pattern is used, the effort of providers and clients are balanced: consumers have a defined time window to migrate to a new API version while providers do not have to support an unlimited number of API versions for an undefined amount of time. As a result, this pattern also defines the responsibilities of both parties to plan their life cycle: the provider can introduce new and possibly incompatible versions but has to support multiple versions, whereas the client must migrate to a new version in a limited time but can more freely and flexibly plan its release schedule.", "Implementation hints": "When applying the *Two in Production* pattern, a number of concerns have to be considered:\n* Enforce and enact the deletion policy. We have often encountered client/project situations in which old versions eligible for deletion were still being offered. Usually this happens for two reasons: a) laziness and/or b) pressure by clients. In both situations, the deletion policy should be clearly communicated and reviewed. This is important because not enforcing the deletion policy leads to clients ignoring or forgetting that versions will get unavailable and rely on officially unsupported versions and taking for granted that these will be available forever. The original provider intention of getting rid of old versions then degenerates quickly, and effectively an *Eternal Lifetime Guarantee* is established implicitly and unofficially.\n* Choose the window of active versions. Although the pattern name implies a version window of two active versions, it might be better to use the *N in Production* variant to allow for a larger window, e.g., three or four versions. The *window size* should depend on the agility of the clients and the update frequency of the API: it should be chosen so that clients can realistically follow with the updates. For example, an agile project might release a new API version in every fortnightly or weekly iteration, which makes it impossible for non-agile clients with quarterly deployments to follow when only the latest two versions are supported. \n* Do not release incompatible versions when it is not necessary. It is easier for the API designer to make breaking changes (e.g., implied by always changing the *Version Identifier*), but this unnecessarily shifts the window of active versions and creates effort on both the provider and the client side for changing the API version. Compatible changes can and should still be made in the \"old\" API version. Otherwise consider adopting *Semantic Versioning*.\n* In the release notes, make the changes between versions explicit (including changes to non-code artifacts such as *Service Level Agreements*).\n* Provide migration examples that take the *Two in Production* approach into account (e.g., feature upgrade from Version 1 to Version 3 in the above example). \n* (Micro-)services middleware such as API Gateways @Richardson:2016 and SOA middleware like Enterprise Service Buses @Pautasso:2017:MSIP can implement the Content-Based Router pattern @Hohpe:2003:EIP and mediate calls from older clients to a newer API  endpoint. This allows providers to save effort by maintaining only the implementation of the newest API version and providing older clients access via light-weight service adapters. ", "Resolution of forces": "* Clients can plan changes well in advance and do not have to migrate exactly when the provider releases a new API version\n* Parallel versions offer a high degree of compatibility and the ability to roll back to an older API version\n* Reduces the likelihood of undetected compatibility changes by keeping old clients on old versions for some time\n* Reduces cost for maintenance by being able to reduce technical debt between different versions without considering backwards-compatibility\n* Clients have to adapt to incompatible API changes over time\n* Limits ability to respond to urgent change requests\n* Causes additional costs for operating multiple API versions\n* Quicker changes by provider result in shorter time intervals for client migrations"}', 'https://microservice-api-patterns.org/patterns/evolution/icons/MAP-TwoInProduction.png', '{"Forces": "*Two in Production* balances the following forces:\n* Allowing the provider and the client to follow *different life cycles* so that a provider can roll out a new API version without breaking clients using the previous API version.\n* Guaranteeing that API changes do not lead to *undetected backwards-compatibility problems* between clients and the provider.\n* Ability to *roll back* if a new API version is designed badly. \n* Minimizing *changes to the client* caused by API changes.\n* Minimizing the *maintenance effort* for supporting clients relying on old API versions.", "Context": "An API evolves and new versions with improved functionality are offered regularly. At some point in time, the changes of a new version are not backwards compatible anymore, thereby \"breaking\" existing clients. However, clients, especially of a *Public API* or a *Community API*, evolve at different speeds; some of them cannot be forced to upgrade to the latest version in a short time frame because the release cycles of the provider(s) and client(s) do not align well with each other.", "Details": "Under independent life cycles with different deployment frequencies and deployment dates of providers and their clients, it becomes necessary to plan API evolution beforehand because it is impossible to make arbitrary changes to an already published API.\n\n**Allowing the provider and the client to follow different life cycles.** When changing an API over time, one of the main problems is how (and for how long) to support clients of older API versions. Keeping old API versions alive usually requires additional resources and effort for operations and maintenance, for instance for bug fixes, security fixes, migrations to newer versions of dependencies, and subsequent regression testing for different API versions. This inflicts cost and binds development resources on the provider side. \nHowever, it is not always possible to just switch off an old version because clients often do not follow the same life cycle: Even within the same company it is difficult or even impossible to roll out two systems at the same point in time, especially if they are owned by different organizational units. The problem becomes worse if there are multiple clients which are owned by different organizations or the clients are even unknown to the provider (e.g., in *Public API* scenarios). Thus, it is often necessary to decouple the life cycles of the client and the provider. Such autonomy/independent life cycles are one of the core tenets of microservices.\n\n**Guaranteeing that API changes do not lead to undetected backwards-compability problems (especially in semantics) between clients and the provider.**  Introducing backwards-compatible changes only is hard, in particular if done without the proper tooling. There is a risk of changes that will quietly introduce problems, e.g., by changed semantics of existing attributes in requests and responses, which cannot be detected syntactically.\n\n**Ability to roll back if a new API version is designed badly.** When redesigning or restructuring an API thoroughly, the new design might not work as expected. For example, functionality required by some clients might unintentionally be removed. Being able to fall back and undo a change helps to not break those clients for a longer time-span.\n\n**Minimizing changes to the client.** Clients in general prefer stability. When API is released it can be assumed to work as intended. Only changes solely required for satisfying (technical) API changes require the clients to be updated in that case. Such updates bind resources and cost money (which would be better spent for delivering more business value). However, providing such highly stable APIs requires more upfront effort on the provider side; provider-side agility may trigger undesired client-side changes.\n\n**Minimizing the maintenance effort for supporting clients relying on old API versions.** The solution must not only take the client effort into consideration, but balance it with the effort on the provider side to maintain multiple API versions, for instance versions supporting not frequently used (and therefore unprofitable) features.", "Example": "A business software vendor releases an API (Version 1) to its Enterprise Resource Planning (ERP) system. In the continued development of the ERP system, an existing payroll API in the HR module is extended; at some point, new pension plan management features break the API because the data retention policies are incompatible. Because the vendor uses the *Two in Production* pattern, it releases its software with the old API (Version 1) and the new API (Version 2). Customers that use Version 1 can roll out the ERP system (HR module) and then start migrating to use Version 2. New customers in the affected country can start to use the new features of the API Version 2 right away.\nWith the next release, the software vendor again releases a new API (Version 3) and removes support for Version 1 because Versions 2 and 3 are now supported. Customers that still use Version 1 are cut off until they have migrated to a more recent version (that they can be redirected to). Clients using Version 2 can stay on Version 2 until the next API version is released. ", "Problem": "How can a provider gradually update an API without breaking existing clients, but also without having to maintain a large number of API versions in production?", "Solution": "Deploy and support two versions of an API endpoint and its operations that provide variations of the same functionality, but do not have to be compatible with each other. Update and decommission (i.e., deprecate and remove) the versions in a rolling, overlapping fashion.\nAs a variant, consider to support more than two versions, for instance three. ", "Known Uses": "Known uses for this pattern include:\n* Terravis @Luebke:2016 offers two major versions in parallel for two years.\n* A large bank in Europe keeps two major versions (see *Semantic Versioning* for definition of \"major\") in parallel.\n* The Dynamic Interface described in @Brandner:2004:SI applies the pattern as well.\n* [GitHub offers a v3 API, but also the next version in parallel](https://developer.github.com/v3/versions/).\n* Facebook describes a rolling release and update policy as well, which is a defining characteristic of *Two in Production*. See their documentation page [\"Platform Versioning\"](https://developers.facebook.com/docs/apps/versions). ", "References": "Brandner, Michael, Michael Craes, Frank Oellermann, and Olaf Zimmermann. 2004. “Web Services-Oriented Architecture in Production in the Finance Industry.” Informatik-Spektrum 27 (2): 136–45. [https://doi.org/10.1007/s00287-004-0380-2](https://doi.org/10.1007/s00287-004-0380-2) \n\nFachat, André. 2019. “Challenges and Benefits of the Microservice Architectural Style.” IBM Developer. [https://developer.ibm.com/articles/challenges-and-benefits-of-the-microservice-architectural-style-part-2/](https://developer.ibm.com/articles/challenges-and-benefits-of-the-microservice-architectural-style-part-2/).\n\nHohpe, Gregor, and Bobby Woolf. 2003. Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions. Addison-Wesley.\n\nLübke, Daniel, and Tammo van Lessen. 2016. “Modeling Test Cases in BPMN for Behavior-Driven Development.” IEEE Software 33 (5): 15–21.\n\nMurer, Stephan, Bruno Bonati, and Frank Furrer. 2010. Managed Evolution - a Strategy for Very Large Information Systems. Heidelberg: Springer.\n\nPautasso, Cesare, Olaf Zimmermann, Mike Amundsen, James Lewis, and Nicolai M. Josuttis. 2017. “Microservices in Practice, Part 1: Reality Check and Service Design.” IEEE Software 34 (1): 91–98. [https://doi.org/10.1109/MS.2017.24](https://doi.org/10.1109/MS.2017.24).\n\nRichardson, Chris. 2016. “Microservice Architecture.” [http://microservices.io](http://microservices.io).", "Consequences": "", "How it works": "Such a rolling dual support strategy can be realized in the following way:\n* Choose how to identify a version (e.g., by using the *Version Identifier* pattern).\n* Offer a fixed number (usually two, thus the pattern name) of API versions in parallel and inform your clients about this life cycle choice.\n* When releasing a new API version, retire the oldest one that still runs in production and inform remaining clients (if any) about their migration options. Redirect calls to the retired version, for instance by leveraging protocol-level capabilities such as those in HTTP.\n By following these steps, a sliding window of active versions is created (see figure below). Thereby, providers allow clients to choose the time of migration to a newer version. If a new version is released, the client can continue to use the previous version and migrate later on (e.g., within a given time frame if the *Limited Lifetime Guarantee* is applied as well). They can learn about the API changes and required client-side modifications without risking the stability of their own primary production system.\n \n ![Version Life Cycles when Using Two In Production](https://microservice-api-patterns.org/patterns/evolution/TwoInProduction.png)\n \n Although typically two versions are offered in parallel, this pattern can also be applied in a slightly changed variant as *N in Production* (or *Several in Production*) where the sliding window of active versions is increased to N (with N greater than 2). This strategy gives clients more time to migrate but places more maintenance effort and operational costs on the provider side. \n \n For example, with three in production, one version may be for legacy clients, one for current clients and one for future ones/early adopters (with the newest version serving as *Experimental Preview*). Only when all legacy traffic disappears, Version 1 can be switched off; Version 2 becomes the legacy as Version 3 stabilizes and a new Version 4 can be experimented with. The oldest one then becomes the legacy in turn, and the newest one can be offered to experimental clients while also providing access to the current stable version.", "Non-solution": "An obvious \"solution\" is not to care about versioning, always roll out the newest version, and force clients to \"live at the head\".  For instance, in the past some enterprise-wide Service-Oriented Architecture (SOA) initiatives have been rolled out without any considerations to versioning and life cycle management with the intention to add such capabilities later on. This is difficult, if not impossible: as soon as an API or service is published, clients will use it and are thus bound to the API; not all changes can be expected to be backward compatible. In such situations, organizations have to mitigate the problems as quickly as possible and roll out the new version side-by-side to the old version. While this solves the problem in the short term, the growing numbers of available API versions are hard to maintain for the providers and confusion starts with regard to which API version and associated deployment are to be used.", "Other Sources": "\"Managed Evolution\" covers life cycle management on a general level, but also dives into API versioning. Section 3.5.4 reports a combined usage of *Semantic Versioning* and *Two in Production*. Three versions are reported to have proven as a good compromize between provider complexity and adaptation pace Murer, Bonati, and Furrer ([2010](https://microservice-api-patterns.org/patterns/evolution/TwoInProduction.html#ref-Murer:2010)).\n\n\"Challenges and benefits of the microservice architectural style\", a two-part article on the IBM Developer portal Fachat ([2019](https://microservice-api-patterns.org/patterns/evolution/TwoInProduction.html#ref-Fachat:2019)), recommends this pattern.", "More Information": "", "Related Patterns": "The usage of this pattern usually requires the *Version Identifier* pattern in order to distinguish the API versions that are currently active and supported concurrently. Fully compatible versions, e.g., as indicated by the patch version in *Semantic Versioning* can replace active versions without violating the *Two in Production* constraints. This should be reported in the *API Description* and/or the *Service Level Agreement*.\n\n*Aggressive Obsolescence* can be used to force clients to stop using the older API version and migrate to the newer one so that the provider can introduce an even newer API version. If the client requires more guarantees on the expiration date of the old API version, the *Limited Lifetime Guarantee* pattern might be more applicable. An *Experimental Preview* can be one of the versions in production. ", "Further discussion": "By using *Two in Production*, the life cycle of provider and client are decoupled to a certain extent: clients do not need to synchronously release their software with the provider. Instead, they have a time window in which they can migrate, test, and release their software. However, clients must migrate as they cannot rely on an *Eternal Lifetime Guarantee* for the API. This means that they have to plan and allocate resources for migrating their software.\n\nWhen this pattern is used, the effort of providers and clients are balanced: consumers have a defined time window to migrate to a new API version while providers do not have to support an unlimited number of API versions for an undefined amount of time. As a result, this pattern also defines the responsibilities of both parties to plan their life cycle: the provider can introduce new and possibly incompatible versions but has to support multiple versions, whereas the client must migrate to a new version in a limited time but can more freely and flexibly plan its release schedule.", "Implementation hints": "When applying the *Two in Production* pattern, a number of concerns have to be considered:\n* Enforce and enact the deletion policy. We have often encountered client/project situations in which old versions eligible for deletion were still being offered. Usually this happens for two reasons: a) laziness and/or b) pressure by clients. In both situations, the deletion policy should be clearly communicated and reviewed. This is important because not enforcing the deletion policy leads to clients ignoring or forgetting that versions will get unavailable and rely on officially unsupported versions and taking for granted that these will be available forever. The original provider intention of getting rid of old versions then degenerates quickly, and effectively an *Eternal Lifetime Guarantee* is established implicitly and unofficially.\n* Choose the window of active versions. Although the pattern name implies a version window of two active versions, it might be better to use the *N in Production* variant to allow for a larger window, e.g., three or four versions. The *window size* should depend on the agility of the clients and the update frequency of the API: it should be chosen so that clients can realistically follow with the updates. For example, an agile project might release a new API version in every fortnightly or weekly iteration, which makes it impossible for non-agile clients with quarterly deployments to follow when only the latest two versions are supported. \n* Do not release incompatible versions when it is not necessary. It is easier for the API designer to make breaking changes (e.g., implied by always changing the *Version Identifier*), but this unnecessarily shifts the window of active versions and creates effort on both the provider and the client side for changing the API version. Compatible changes can and should still be made in the \"old\" API version. Otherwise consider adopting *Semantic Versioning*.\n* In the release notes, make the changes between versions explicit (including changes to non-code artifacts such as *Service Level Agreements*).\n* Provide migration examples that take the *Two in Production* approach into account (e.g., feature upgrade from Version 1 to Version 3 in the above example). \n* (Micro-)services middleware such as API Gateways @Richardson:2016 and SOA middleware like Enterprise Service Buses @Pautasso:2017:MSIP can implement the Content-Based Router pattern @Hohpe:2003:EIP and mediate calls from older clients to a newer API  endpoint. This allows providers to save effort by maintaining only the implementation of the newest API version and providing older clients access via light-weight service adapters. ", "Resolution of forces": "* Clients can plan changes well in advance and do not have to migrate exactly when the provider releases a new API version\n* Parallel versions offer a high degree of compatibility and the ability to roll back to an older API version\n* Reduces the likelihood of undetected compatibility changes by keeping old clients on old versions for some time\n* Reduces cost for maintenance by being able to reduce technical debt between different versions without considering backwards-compatibility\n* Clients have to adapt to incompatible API changes over time\n* Limits ability to respond to urgent change requests\n* Causes additional costs for operating multiple API versions\n* Quicker changes by provider result in shorter time intervals for client migrations"}', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');
INSERT INTO public.pattern (id, name, uri, content, icon_url, rendered_content, pattern_language_id) VALUES ('06154132-0892-4e88-b811-7e21d92a7498', 'Aggressive Obsolescence', 'https://patternpedia.org/patternLanguages/microserviceApiPatterns/aggressiveObsolescence', '{"Forces": "*Aggressive Obsolescence* needs to balance the following forces:\n* Minimizing the *maintenance effort* (e.g., limiting support for old clients)\n* Reducing *forced changes to clients* in a given time-span (as a consequence of API changes)\n* Acknowledging and respecting *power balances* between API provider and client, for instance, the ability of clients to steer API design and evolution. \n* Respecting *commercial goals and constraints*, e.g., impact on *->Rate Plan*", "Context": "Once an API has been released, it evolves and new versions with added, removed or changed functionality are offered. In order to reduce effort, API providers do not want to support certain functionalities for clients anymore, e.g., because they are no longer used regularly or are superseded by alternative versions.", "Details": "**Minimizing the maintenance effort.** Allowing the provider to discontinue support of unnecessary or unfeasible parts of an API or an API as a whole helps to reduce the maintenance effort. Supporting old clients can be particularly painful. \n\n**Reducing forced changes to clients in a given time-span as a consequence of API changes.** It is often not possible to just switch off an old version because clients do not follow the same life cycle as the provider: Even within the same organization it is often difficult or impossible to roll out upgrades to two systems at the same point in time if they are owned by different organizational units. The problem becomes worse if the systems are owned by different organizations or the clients are even unknown to the provider. Therefore, it is often necessary to decouple the life cycles of clients and providers. This decoupling can be achieved by giving clients time to make any changes necessary. In order to reduce the impact of changes to clients, it is also useful to be able not to remove a whole API version but to remove only certain obsolete parts (for instance operations, parameter or elements of the return values). Removing only parts of an API reduces the impact of API changes to clients compared to not supporting a whole API version anymore: Because some clients might not be affected by the removal because they do not depend on the particular discontinued feature(s).\n\n**Respecting/acknowledging power dynamics.** Organizational unity and teams may influence each other in various ways, from (in-) formal hearings to official voting and approvals. Political factors influence the solution space. For example, a high-profile customer has good leverage with a provider that it can swap in and out easily; on the contrary, a monopolist offering a unique API can impose changes on millions of clients without involving them much -- as they have nowhere else to turn to. Depending on the ratio of API clients per providers, it might be worthwhile to place more effort on one role to keep up with the evolution of the other.\n\n**Commercial goals and constraints.** Removing obsolete APIs or API features might have monetary consequences. For instance, If a commercial *->Rate Plan* is in place, clients can be asked to pay upgrade fees to generate extra revenue for providers.", "Example": "A payment provider offers an API that allows clients to instruct payments from their accounts to other accounts. Accounts can be identified by old-fashioned, country-specific account and bank numbers or by [International Bank Account Number (IBAN)](https://en.wikipedia.org/wiki/International_Bank_Account_Number). Because IBANs are the new standard and the old account and bank numbers are rarely used, the API provider decides to not support the old numbers anymore. This allows the provider to delete parts of its implementation, thereby reducing the maintenance effort.\nIn order to allow old clients to migrate to the IBAN scheme, the provider publishes a removal announcement on its API documentation Web page, marks the account and bank number as deprecated in the API documentation, and notifies clients that are registered with the service. The announcement states that the old, country-specific functionality will be removed after one year.\nAfter one year, the payment provider deploys a new implementation of the API that has no support of the old account and bank numbers and removes the old, country-specific attributes from its API documentation. Calls to the old API version fail from now on.\nIt is notable that in this case, legislature had also specified a transition period to the IBAN system along the lines of deprecating the old, country-specific account number scheme.", "Problem": "How can API providers reduce the effort required to maintain APIs (and their exposed functionality) for existing clients \n(of a previously released API version)? ", "Solution": "Announce a decommissioning date to be set as early as possible for obsolete API endpoints, operations or message representations. Declare such API elements to be immediately deprecated (i.e., still available, but no longer recommended to be used) so that clients have barely enough time to upgrade to a newer or alternative version before the API elements they depend on disappear. Remove the API and the support for it as soon as the deadline has passed.", "Known Uses": "The *->Aggressive Obsolescence* Pattern is frequently used in large APIs. Some examples are:\n* Google has sometimes been reported to implement this pattern in the context of its online services, e.g., [Google Reader](https://www.google.com/reader/about/) and [Google Wave](https://support.google.com/answer/1083134?hl=en).\n* Riot Games uses (or used) this pattern for the [Riot Games API](https://developer.riotgames.com/docs/portal#web-apis_versioning).\n* Microsoft uses a 24 month deprecation period on [MS Graph](https://developer.microsoft.com/en-us/graph/docs/concepts/versioning_and_support).\n* Aggressive Obsolescence is also used in local programming APIs, e.g., the [ZEND Framework](https://github.com/zendframework/zend-mvc/commit/0a531e25bc8ec8e10b4730dfb609b6ff34f8b7b6). \n* Mike Amundsen reports the use of this pattern in \"Microservices in Practice, Part 2\" @Pautasso:2017:MSIP2.", "References": "", "Consequences": "", "How it works": "When releasing an API the provider should clearly communicate that it follows an *>Aggressive Obsolescence* strategy, i.e., that a particular feature might be deprecated and subsequently decommissioned (i.e., removed from support) anytime in the future. When an API, operation or representation element is to be removed, the provider declares this element of the API as deprecated and specifies a time frame by when the feature will be removed completely. Depending on their market position and the availability of alternatives, clients can then chose to upgrade or to switch to a different provider.\n*>Aggressive Obsolescence* makes old API versions as a whole -- or parts thereof -- unavailable rather quickly, for instance within a year for an enterprise application API. \nWhen the needs of the provider(s) outweigh those of the client(s), this *>Aggressive Obsolescence* strategy can be followed.\nBy clearly announcing the deprecation and removal schedule for old versions of APIs or API features, the provider can reduce and limit effort for supporting API features that are not support-worthy in a broad sense, e.g., economically because the feature is too costly to maintain (e.g., rarely used features), or legally because a feature becomes unavailable (e.g., introduction of IBAN replaces old account numbers or the introduction of the Euro currency replaces many other currencies). This allows clients to plan the required effort and deployment schedules for still using the service and migrate to an alternative way of achieving the required functionality after a deprecation notice has been issued. \n![API life cycle when using Aggressive Obsolescence](https://microservice-api-patterns.org/patterns/evolution/AggressiveObsolescence.png)\n\nPlanning obsolescence and removal usually involves a four-step process (see graphic above) after a provider releases an API and reserves the right to deprecate and remove parts of it:\n* API version is used in production: Clients happily use the API (Version V1 in the figure)\n* Deprecation: The provider announces the deprecation of an API, API version, or functionality within an API version and indicates when the functionality will be removed (for example, with the next release or at a specific date; Version V2 in the figure) \n* Clients receive the announcement plan and migrate to API replacement versions -- or in extreme cases switch to alternative providers.\n* Removal/decommissioning: The provider deploys a new API version that does not support the deprecated functionality anymore. The old version is taken down and retired/archived; requests to the old endpoint can either fail or be redirected to the new version endpoint. (Version V3 in the figure)\n* Clients that did not migrate and depend on removed parts of the API no longer work.\n* Sometimes *>Aggressive Obsolescence* might be the only option for API providers that have not declared any life cycle policies beforehand. If no guarantees are given, deprecating features and announcing -- possibly generous -- transition periods might be a good way to be able to make incompatible changes again.", "Non-solution": "One could give no guarantees or follow a rather short *->Limited Lifetime Guarantee*, but such weak commitments do not really minimize the impact of changes. One could declare an API to be an *->Experimental Preview*, but this is an even weaker commitment that might not be well received by clients.", "Other Sources": "“Managed Evolution” Murer, Bonati, and Furrer ([2010](https://microservice-api-patterns.org/patterns/evolution/AggressiveObsolescence.html#ref-Murer:2010)) shares general information on service governance and versioning, for instance how to define quality gates and how to monitor traffic. Chapter 7 deals with “Measuring the Managed Evolution”. ", "More Information": "", "Related Patterns": "Other patterns defining the life cycle also deal with the discontinuation of services. Several strategies can be employed, as outlined in the *->Two in Production*, *->Limited Lifetime Guarantee* and *->Eternal Lifetime Guarantee* patterns. In contrast, our *->Aggressive Obsolescence* pattern can be used in a more fine-grained way because it aims at removing functionality from an API, which is not necessarily bound to syntactic units: While other versioning schemes are attached to operations or set of operations, only certain representation elements might get deprecated and removed in *->Aggressive Obsolescence*, thereby allowing less obstructive changes.\n\nAnother difference to other patterns is that *->Aggressive Obsolescence* always uses relative timeframes for removing functionality: Because functionality becomes obsolete during the lifetime of an API, it gets flagged deprecated within its active period and the deprecation period runs from this time onwards. In contrast, *->Two in Production* or *->Limited Lifetime Guarantee* can be used with absolute timeframes based on the initial release date. \n\nFinally, the pattern cannot only be applied proactively, but also reactively during API maintenance.\nThe pattern may or may not use a *->Version Identifier*. If present, an *->API Description* or a *->Service Level Agreement* should indicate the usage of this pattern. ", "Further discussion": "*->Aggressive Obsolescence* can be used to enforce a coherent and secure ecosystem around the APIs offered: For example, sunsetting weak cryptographic algorithms, out-phased standards or inefficient libraries can help in achieving a better overall experience for all involved parties.\n\nSupporting old clients requires effort for maintaining old API implementations, building service adapters or introducing complicated structures for retaining backwards-compatibility in messages. In order to reduce maintenance effort and technical debt, a mechanism is required that constrains the life-time of functionality and imposes rules that allow existing clients to plan their updates.\nThe *->Aggressive Obsolescence* pattern emphasizes the reduction of effort on the provider side but burdens clients. Essentially, it requires the clients to continuously evolve with the API. In turn, clients stay current with the newest functions and improvements and thus also benefit from switching away from old versions, e.g., they are forced to use new security standards. Depending on the deprecation period, clients can plan and follow API changes like with the *->Limited Lifetime Guarantee* pattern but requires them to be rather active.\n\nHowever, depending on the versioning policy (see *->Version Identifier* and *->Semantic Versioning*), it is not straightforward to come up with a suitable deprecation and decommissioning policy. If versioning happens on a fine-grained level, e.g., by versioning the content-type of every individual REST resource representation, it is hard to keep track of cluttered and distributedly managed entities for deprecation and removal.\n\nFurthermore, communicating the entities to be deprecated and removed is difficult in such scenarios.\nEspecially in in-house scenarios the knowledge of which systems are using an API (or the deprecated subset of an API) is of great help when deciding if and which features or APIs should be removed. Inter-company services are usually more restrictive and try to better guarantee that other systems might not fail to work properly. Thus, additional care must be taken before an API or functionality is finally removed. Knowing the relationships between systems and establishing dependency traceability can help with this problem in both scenarios; DevOps practices and supporting tools can be leveraged (e.g., for monitoring and distributed log analysis).\n\nIn some business contexts, external clients are managed less diligently than internal clients, and usage dependencies are of no great importance to the API provider. In such circumstances, using the *->Rate Plan* pattern (or at least some metering mechanisms) can help identify services to be deprecated and eventually removed. Rate plans can help to financially measure the economic value of an API which can be compared with the maintenance and development effort, thereby deriving an economic decision about prolonging the API lifetime.", "Implementation hints": "Because *->Aggressive Obsolescence* prioritizes the provider side over the client side, it must be taken care that clients are not unrealistically constrained:\n* The deprecation and removal schedule should be chosen so that clients can realistically migrate to the new API versions.\n* If the clients or a representative subset of clients are known, the deprecation and removal schedule should be communicated to or, even better, negotiated with them.\n* In case of anonymous clients the deprecation schedule and the affected parts of the API should be announced early, clearly, and publicly.\n* If the same or similar functionality is available elsewhere, the documentation should state how the clients can and should replace the deprecated functionality.\n* Providers can also offer more advanced help. For example, Facebook offers an [API Upgrade Tool](https://developers.facebook.com/tools/api_versioning/) that \"will show which of your app''s API calls will be affected by changes in newer versions of the API. This would help mitigate the pain for customers if APIs are aggressively deprecated\".", "Resolution of forces": "* Ideally, clients do not have to change if deprecated functionality is not used.\n* Provider code base is kept small and thus easier to maintain.\n* Providers must announce which features are deprecated and when they will be decommissioned.\n* Clients that rely on rarely used features or take full advantage of all API features are forced to implement modifications with a schedule which might be unknown when the client is released initially. This schedule usually is communicated to the clients upon deprecation and not during the API release, which might or might not fit the client''s release schedule. Furthermore, it might change later in the API life cycle.\n* Clients must get to know obsolete features."}', 'https://microservice-api-patterns.org/patterns/evolution/icons/MAP-AggressiveDeprecation.png', '{"Forces": "*Aggressive Obsolescence* needs to balance the following forces:\n* Minimizing the *maintenance effort* (e.g., limiting support for old clients)\n* Reducing *forced changes to clients* in a given time-span (as a consequence of API changes)\n* Acknowledging and respecting *power balances* between API provider and client, for instance, the ability of clients to steer API design and evolution. \n* Respecting *commercial goals and constraints*, e.g., impact on *->Rate Plan*", "Context": "Once an API has been released, it evolves and new versions with added, removed or changed functionality are offered. In order to reduce effort, API providers do not want to support certain functionalities for clients anymore, e.g., because they are no longer used regularly or are superseded by alternative versions.", "Details": "**Minimizing the maintenance effort.** Allowing the provider to discontinue support of unnecessary or unfeasible parts of an API or an API as a whole helps to reduce the maintenance effort. Supporting old clients can be particularly painful. \n\n**Reducing forced changes to clients in a given time-span as a consequence of API changes.** It is often not possible to just switch off an old version because clients do not follow the same life cycle as the provider: Even within the same organization it is often difficult or impossible to roll out upgrades to two systems at the same point in time if they are owned by different organizational units. The problem becomes worse if the systems are owned by different organizations or the clients are even unknown to the provider. Therefore, it is often necessary to decouple the life cycles of clients and providers. This decoupling can be achieved by giving clients time to make any changes necessary. In order to reduce the impact of changes to clients, it is also useful to be able not to remove a whole API version but to remove only certain obsolete parts (for instance operations, parameter or elements of the return values). Removing only parts of an API reduces the impact of API changes to clients compared to not supporting a whole API version anymore: Because some clients might not be affected by the removal because they do not depend on the particular discontinued feature(s).\n\n**Respecting/acknowledging power dynamics.** Organizational unity and teams may influence each other in various ways, from (in-) formal hearings to official voting and approvals. Political factors influence the solution space. For example, a high-profile customer has good leverage with a provider that it can swap in and out easily; on the contrary, a monopolist offering a unique API can impose changes on millions of clients without involving them much -- as they have nowhere else to turn to. Depending on the ratio of API clients per providers, it might be worthwhile to place more effort on one role to keep up with the evolution of the other.\n\n**Commercial goals and constraints.** Removing obsolete APIs or API features might have monetary consequences. For instance, If a commercial *->Rate Plan* is in place, clients can be asked to pay upgrade fees to generate extra revenue for providers.", "Example": "A payment provider offers an API that allows clients to instruct payments from their accounts to other accounts. Accounts can be identified by old-fashioned, country-specific account and bank numbers or by [International Bank Account Number (IBAN)](https://en.wikipedia.org/wiki/International_Bank_Account_Number). Because IBANs are the new standard and the old account and bank numbers are rarely used, the API provider decides to not support the old numbers anymore. This allows the provider to delete parts of its implementation, thereby reducing the maintenance effort.\nIn order to allow old clients to migrate to the IBAN scheme, the provider publishes a removal announcement on its API documentation Web page, marks the account and bank number as deprecated in the API documentation, and notifies clients that are registered with the service. The announcement states that the old, country-specific functionality will be removed after one year.\nAfter one year, the payment provider deploys a new implementation of the API that has no support of the old account and bank numbers and removes the old, country-specific attributes from its API documentation. Calls to the old API version fail from now on.\nIt is notable that in this case, legislature had also specified a transition period to the IBAN system along the lines of deprecating the old, country-specific account number scheme.", "Problem": "How can API providers reduce the effort required to maintain APIs (and their exposed functionality) for existing clients \n(of a previously released API version)? ", "Solution": "Announce a decommissioning date to be set as early as possible for obsolete API endpoints, operations or message representations. Declare such API elements to be immediately deprecated (i.e., still available, but no longer recommended to be used) so that clients have barely enough time to upgrade to a newer or alternative version before the API elements they depend on disappear. Remove the API and the support for it as soon as the deadline has passed.", "Known Uses": "The *->Aggressive Obsolescence* Pattern is frequently used in large APIs. Some examples are:\n* Google has sometimes been reported to implement this pattern in the context of its online services, e.g., [Google Reader](https://www.google.com/reader/about/) and [Google Wave](https://support.google.com/answer/1083134?hl=en).\n* Riot Games uses (or used) this pattern for the [Riot Games API](https://developer.riotgames.com/docs/portal#web-apis_versioning).\n* Microsoft uses a 24 month deprecation period on [MS Graph](https://developer.microsoft.com/en-us/graph/docs/concepts/versioning_and_support).\n* Aggressive Obsolescence is also used in local programming APIs, e.g., the [ZEND Framework](https://github.com/zendframework/zend-mvc/commit/0a531e25bc8ec8e10b4730dfb609b6ff34f8b7b6). \n* Mike Amundsen reports the use of this pattern in \"Microservices in Practice, Part 2\" @Pautasso:2017:MSIP2.", "References": "", "Consequences": "", "How it works": "When releasing an API the provider should clearly communicate that it follows an *>Aggressive Obsolescence* strategy, i.e., that a particular feature might be deprecated and subsequently decommissioned (i.e., removed from support) anytime in the future. When an API, operation or representation element is to be removed, the provider declares this element of the API as deprecated and specifies a time frame by when the feature will be removed completely. Depending on their market position and the availability of alternatives, clients can then chose to upgrade or to switch to a different provider.\n*>Aggressive Obsolescence* makes old API versions as a whole -- or parts thereof -- unavailable rather quickly, for instance within a year for an enterprise application API. \nWhen the needs of the provider(s) outweigh those of the client(s), this *>Aggressive Obsolescence* strategy can be followed.\nBy clearly announcing the deprecation and removal schedule for old versions of APIs or API features, the provider can reduce and limit effort for supporting API features that are not support-worthy in a broad sense, e.g., economically because the feature is too costly to maintain (e.g., rarely used features), or legally because a feature becomes unavailable (e.g., introduction of IBAN replaces old account numbers or the introduction of the Euro currency replaces many other currencies). This allows clients to plan the required effort and deployment schedules for still using the service and migrate to an alternative way of achieving the required functionality after a deprecation notice has been issued. \n![API life cycle when using Aggressive Obsolescence](https://microservice-api-patterns.org/patterns/evolution/AggressiveObsolescence.png)\n\nPlanning obsolescence and removal usually involves a four-step process (see graphic above) after a provider releases an API and reserves the right to deprecate and remove parts of it:\n* API version is used in production: Clients happily use the API (Version V1 in the figure)\n* Deprecation: The provider announces the deprecation of an API, API version, or functionality within an API version and indicates when the functionality will be removed (for example, with the next release or at a specific date; Version V2 in the figure) \n* Clients receive the announcement plan and migrate to API replacement versions -- or in extreme cases switch to alternative providers.\n* Removal/decommissioning: The provider deploys a new API version that does not support the deprecated functionality anymore. The old version is taken down and retired/archived; requests to the old endpoint can either fail or be redirected to the new version endpoint. (Version V3 in the figure)\n* Clients that did not migrate and depend on removed parts of the API no longer work.\n* Sometimes *>Aggressive Obsolescence* might be the only option for API providers that have not declared any life cycle policies beforehand. If no guarantees are given, deprecating features and announcing -- possibly generous -- transition periods might be a good way to be able to make incompatible changes again.", "Non-solution": "One could give no guarantees or follow a rather short *->Limited Lifetime Guarantee*, but such weak commitments do not really minimize the impact of changes. One could declare an API to be an *->Experimental Preview*, but this is an even weaker commitment that might not be well received by clients.", "Other Sources": "“Managed Evolution” Murer, Bonati, and Furrer ([2010](https://microservice-api-patterns.org/patterns/evolution/AggressiveObsolescence.html#ref-Murer:2010)) shares general information on service governance and versioning, for instance how to define quality gates and how to monitor traffic. Chapter 7 deals with “Measuring the Managed Evolution”. ", "More Information": "", "Related Patterns": "Other patterns defining the life cycle also deal with the discontinuation of services. Several strategies can be employed, as outlined in the *->Two in Production*, *->Limited Lifetime Guarantee* and *->Eternal Lifetime Guarantee* patterns. In contrast, our *->Aggressive Obsolescence* pattern can be used in a more fine-grained way because it aims at removing functionality from an API, which is not necessarily bound to syntactic units: While other versioning schemes are attached to operations or set of operations, only certain representation elements might get deprecated and removed in *->Aggressive Obsolescence*, thereby allowing less obstructive changes.\n\nAnother difference to other patterns is that *->Aggressive Obsolescence* always uses relative timeframes for removing functionality: Because functionality becomes obsolete during the lifetime of an API, it gets flagged deprecated within its active period and the deprecation period runs from this time onwards. In contrast, *->Two in Production* or *->Limited Lifetime Guarantee* can be used with absolute timeframes based on the initial release date. \n\nFinally, the pattern cannot only be applied proactively, but also reactively during API maintenance.\nThe pattern may or may not use a *->Version Identifier*. If present, an *->API Description* or a *->Service Level Agreement* should indicate the usage of this pattern. ", "Further discussion": "*->Aggressive Obsolescence* can be used to enforce a coherent and secure ecosystem around the APIs offered: For example, sunsetting weak cryptographic algorithms, out-phased standards or inefficient libraries can help in achieving a better overall experience for all involved parties.\n\nSupporting old clients requires effort for maintaining old API implementations, building service adapters or introducing complicated structures for retaining backwards-compatibility in messages. In order to reduce maintenance effort and technical debt, a mechanism is required that constrains the life-time of functionality and imposes rules that allow existing clients to plan their updates.\nThe *->Aggressive Obsolescence* pattern emphasizes the reduction of effort on the provider side but burdens clients. Essentially, it requires the clients to continuously evolve with the API. In turn, clients stay current with the newest functions and improvements and thus also benefit from switching away from old versions, e.g., they are forced to use new security standards. Depending on the deprecation period, clients can plan and follow API changes like with the *->Limited Lifetime Guarantee* pattern but requires them to be rather active.\n\nHowever, depending on the versioning policy (see *->Version Identifier* and *->Semantic Versioning*), it is not straightforward to come up with a suitable deprecation and decommissioning policy. If versioning happens on a fine-grained level, e.g., by versioning the content-type of every individual REST resource representation, it is hard to keep track of cluttered and distributedly managed entities for deprecation and removal.\n\nFurthermore, communicating the entities to be deprecated and removed is difficult in such scenarios.\nEspecially in in-house scenarios the knowledge of which systems are using an API (or the deprecated subset of an API) is of great help when deciding if and which features or APIs should be removed. Inter-company services are usually more restrictive and try to better guarantee that other systems might not fail to work properly. Thus, additional care must be taken before an API or functionality is finally removed. Knowing the relationships between systems and establishing dependency traceability can help with this problem in both scenarios; DevOps practices and supporting tools can be leveraged (e.g., for monitoring and distributed log analysis).\n\nIn some business contexts, external clients are managed less diligently than internal clients, and usage dependencies are of no great importance to the API provider. In such circumstances, using the *->Rate Plan* pattern (or at least some metering mechanisms) can help identify services to be deprecated and eventually removed. Rate plans can help to financially measure the economic value of an API which can be compared with the maintenance and development effort, thereby deriving an economic decision about prolonging the API lifetime.", "Implementation hints": "Because *->Aggressive Obsolescence* prioritizes the provider side over the client side, it must be taken care that clients are not unrealistically constrained:\n* The deprecation and removal schedule should be chosen so that clients can realistically migrate to the new API versions.\n* If the clients or a representative subset of clients are known, the deprecation and removal schedule should be communicated to or, even better, negotiated with them.\n* In case of anonymous clients the deprecation schedule and the affected parts of the API should be announced early, clearly, and publicly.\n* If the same or similar functionality is available elsewhere, the documentation should state how the clients can and should replace the deprecated functionality.\n* Providers can also offer more advanced help. For example, Facebook offers an [API Upgrade Tool](https://developers.facebook.com/tools/api_versioning/) that \"will show which of your app''s API calls will be affected by changes in newer versions of the API. This would help mitigate the pain for customers if APIs are aggressively deprecated\".", "Resolution of forces": "* Ideally, clients do not have to change if deprecated functionality is not used.\n* Provider code base is kept small and thus easier to maintain.\n* Providers must announce which features are deprecated and when they will be decommissioned.\n* Clients that rely on rarely used features or take full advantage of all API features are forced to implement modifications with a schedule which might be unknown when the client is released initially. This schedule usually is communicated to the clients upon deprecation and not during the API release, which might or might not fit the client''s release schedule. Furthermore, it might change later in the API life cycle.\n* Clients must get to know obsolete features."}', '1f1120b5-702e-44bb-9efc-18c9ac66aa6f');